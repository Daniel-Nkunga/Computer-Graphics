# Fundamentals of Light
## The Human Visual System
- **Rods**: monochromatic and used for night vision
- **Cones**: detect color

## Perception of Color
- Different colors are made by combining different combinations of red, green, and blue
- **Additive color**: create desired color by emitting different amounts the the three primary colors on black
- **Subtractive color**: create desired color by adding different combinations of magenta, yellow, cyan, and black on white
- We're going to treat each image on the screen as a 2D Array

## Objects
- **Solid objects**: objects that adsorb some portion of the light and reflect the other colors
	- Ex: a red ball would absorb all other colors except red
- **Transparent object**: objects that change the direction of light passing through it based off the index of refraction
- **Reflective object**: objects that reflect almost off the light back onto the environment
- **Ray**: beams of light starting at the source and going to every other object in the environment
	- Only rays that bounce off an object and back to our eyes (the camera) are seen
	- Many rays will NOT be seen üíÄ

## Pinhole Cameras
- *Assume a pinhole is at (0,0,0) and pointing down the Z-axis*
- The image will be presented on a plane at the back of a pinhole camera -- a distance $d$ away -- onto the point $(x^p, y^p, z^p) = (-xd/z, -yd/z, -d)$
	- $x_p = (x*d)/z$
	  $y_p = (y*d)/z$
	  This derivation allows us to show that objects that are further away are perceived to be smaller üêù (This is apparently very relevant and a major takeaway he wants us to have is to be able to re-derive this üíÄ)

## Rendering
- **Rendering**: the process of going from a mathematical model of what should be seen to a graphical image
- Basic rending approaches (all start from the camera itself):
	- **Ray tracing**: calculate the color of every object hitting the camera by tracing it backwards to the scene (camera to object)
		- Can be *easily* parallelized because the rays will not interact with each other
	- **Radiosity**: uses finite element analysis (fancy math) to calculate how much light reaches each object in the scene 
		1. Break down the scene into parches
		2. Calculate visibility between all pairs of patches
		3. Initialize color of each patch using direct illumination
		4. Iterate (recur) finite element model until light converges
	- **Object based rendering**: calculates where each object in the scene should appear in the projected image‚Äã
- 